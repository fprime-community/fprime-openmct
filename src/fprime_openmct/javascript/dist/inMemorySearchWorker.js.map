{"version":3,"file":"inMemorySearchWorker.js","mappings":"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","sources":["webpack://openmct/webpack/universalModuleDefinition","webpack://openmct/./src/api/objects/InMemorySearchWorker.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"openmct\"] = factory();\n\telse\n\t\troot[\"openmct\"] = factory();\n})(this, () => {\nreturn ","/*****************************************************************************\n * Open MCT, Copyright (c) 2014-2023, United States Government\n * as represented by the Administrator of the National Aeronautics and Space\n * Administration. All rights reserved.\n *\n * Open MCT is licensed under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0.\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n *\n * Open MCT includes source code licensed under additional open source\n * licenses. See the Open Source Licenses file (LICENSES.md) included with\n * this source code distribution or the Licensing information page available\n * at runtime from the About dialog for additional information.\n *****************************************************************************/\n\n/**\n * Module defining InMemorySearchWorker. Created by deeptailor on 10/03/2019.\n */\n(function () {\n  // An object composed of domain object IDs and models\n  // {id: domainObject's ID, name: domainObject's name}\n  const indexedDomainObjects = {};\n  const indexedAnnotationsByDomainObject = {};\n  const indexedAnnotationsByTag = {};\n\n  self.onconnect = function (e) {\n    const port = e.ports[0];\n\n    port.onmessage = function (event) {\n      const requestType = event.data.request;\n      if (requestType === 'index') {\n        indexItem(event.data.keyString, event.data.model);\n      } else if (requestType === 'OBJECTS') {\n        port.postMessage(searchForObjects(event.data));\n      } else if (requestType === 'ANNOTATIONS') {\n        port.postMessage(searchForAnnotations(event.data));\n      } else if (requestType === 'TAGS') {\n        port.postMessage(searchForTags(event.data));\n      } else {\n        throw new Error(`Unknown request ${event.data.request}`);\n      }\n    };\n\n    port.start();\n  };\n\n  self.onerror = function (error) {\n    //do nothing\n    console.error('Error on feed', error);\n  };\n\n  function indexAnnotation(objectToIndex, model) {\n    Object.keys(model.targets).forEach((targetID) => {\n      if (!indexedAnnotationsByDomainObject[targetID]) {\n        indexedAnnotationsByDomainObject[targetID] = [];\n      }\n\n      objectToIndex.targets = model.targets;\n      objectToIndex.tags = model.tags;\n      const existsInIndex = indexedAnnotationsByDomainObject[targetID].some((indexedObject) => {\n        return indexedObject.keyString === objectToIndex.keyString;\n      });\n\n      if (!existsInIndex) {\n        indexedAnnotationsByDomainObject[targetID].push(objectToIndex);\n      }\n    });\n  }\n\n  function indexTags(keyString, objectToIndex, model) {\n    // add new tags\n    model.tags.forEach((tagID) => {\n      if (!indexedAnnotationsByTag[tagID]) {\n        indexedAnnotationsByTag[tagID] = [];\n      }\n\n      const existsInIndex = indexedAnnotationsByTag[tagID].some((indexedObject) => {\n        return indexedObject.keyString === objectToIndex.keyString;\n      });\n\n      if (!existsInIndex) {\n        indexedAnnotationsByTag[tagID].push(objectToIndex);\n      }\n    });\n    // remove old tags\n    const tagsToRemoveFromIndex = Object.keys(indexedAnnotationsByTag).filter((indexedTag) => {\n      return !model.tags.includes(indexedTag);\n    });\n    tagsToRemoveFromIndex.forEach((tagToRemoveFromIndex) => {\n      indexedAnnotationsByTag[tagToRemoveFromIndex] = indexedAnnotationsByTag[\n        tagToRemoveFromIndex\n      ].filter((indexedAnnotation) => {\n        const shouldKeep = indexedAnnotation.keyString !== keyString;\n\n        return shouldKeep;\n      });\n    });\n  }\n\n  function indexItem(keyString, model) {\n    const objectToIndex = {\n      type: model.type,\n      name: model.name,\n      keyString\n    };\n    if (model && model.type === 'annotation') {\n      if (model.targets) {\n        indexAnnotation(objectToIndex, model);\n      }\n\n      if (model.tags) {\n        indexTags(keyString, objectToIndex, model);\n      }\n    } else {\n      indexedDomainObjects[keyString] = objectToIndex;\n    }\n  }\n\n  /**\n   * Gets search results from the indexedItems based on provided search\n   *   input. Returns matching results from indexedItems\n   *\n   * @param data An object which contains:\n   *           * input: The original string which we are searching with\n   *           * maxResults: The maximum number of search results desired\n   *           * queryId: an id identifying this query, will be returned.\n   */\n  function searchForObjects(data) {\n    let results = [];\n    const input = data.input.trim().toLowerCase();\n    const message = {\n      request: 'searchForObjects',\n      results: [],\n      total: 0,\n      queryId: data.queryId\n    };\n\n    results =\n      Object.values(indexedDomainObjects).filter((indexedItem) => {\n        return indexedItem.name.toLowerCase().includes(input);\n      }) || [];\n\n    message.total = results.length;\n    message.results = results.slice(0, data.maxResults);\n\n    return message;\n  }\n\n  function searchForAnnotations(data) {\n    let results = [];\n    const message = {\n      request: 'searchForAnnotations',\n      results: [],\n      total: 0,\n      queryId: data.queryId\n    };\n\n    results = indexedAnnotationsByDomainObject[data.input] || [];\n\n    message.total = results.length;\n    message.results = results.slice(0, data.maxResults);\n\n    return message;\n  }\n\n  function searchForTags(data) {\n    let results = [];\n    const message = {\n      request: 'searchForTags',\n      results: [],\n      total: 0,\n      queryId: data.queryId\n    };\n\n    if (data.input) {\n      data.input.forEach((matchingTag) => {\n        const matchingAnnotations = indexedAnnotationsByTag[matchingTag];\n        if (matchingAnnotations) {\n          matchingAnnotations.forEach((matchingAnnotation) => {\n            const existsInResults = results.some((indexedObject) => {\n              return matchingAnnotation.keyString === indexedObject.keyString;\n            });\n            if (!existsInResults) {\n              results.push(matchingAnnotation);\n            }\n          });\n        }\n      });\n    }\n\n    message.total = results.length;\n    message.results = results.slice(0, data.maxResults);\n\n    return message;\n  }\n})();\n"],"names":["root","factory","exports","module","define","amd","this","indexedDomainObjects","indexedAnnotationsByDomainObject","indexedAnnotationsByTag","self","onconnect","e","port","ports","onmessage","event","requestType","data","request","keyString","model","objectToIndex","type","name","targets","Object","keys","forEach","targetID","tags","some","indexedObject","push","indexAnnotation","tagID","filter","indexedTag","includes","tagToRemoveFromIndex","indexedAnnotation","indexTags","indexItem","postMessage","results","input","trim","toLowerCase","message","total","queryId","values","indexedItem","length","slice","maxResults","searchForObjects","searchForAnnotations","Error","matchingTag","matchingAnnotations","matchingAnnotation","searchForTags","start","onerror","error","console"],"sourceRoot":""}